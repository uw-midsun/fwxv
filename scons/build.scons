from scons.common import parse_config
import subprocess
import os

Import("VARS")

TYPE = VARS.get("TYPE")
TARGET = VARS.get("TARGET")
PLATFORM = VARS.get("PLATFORM")
env = VARS.get("env")

ROOT = Dir('#')

BUILD_DIR = ROOT.Dir('build').Dir(PLATFORM)
BIN_DIR = BUILD_DIR.Dir('bin')
OBJ_DIR = BUILD_DIR.Dir('obj')
TEST_DIR = BUILD_DIR.Dir('test')

PY_DIR = ROOT.Dir('py')
PROJ_DIR = ROOT.Dir('projects')
LIB_DIR = ROOT.Dir('libraries')
SMOKE_DIR = ROOT.Dir('smoke')
CAN_DIR = ROOT.Dir('can')

PROJ_DIRS = [entry for entry in PROJ_DIR.glob('*')]
LIB_DIRS = [entry for entry in LIB_DIR.glob('*')]
SMOKE_DIRS = [entry for entry in SMOKE_DIR.glob('*')]

LIB_BIN_DIR = BIN_DIR.Dir('libraries')

PLATFORM_DIR = ROOT.Dir('platform')

CODEGEN_DIR = LIB_DIR.Dir("codegen")
BOARDS_DIR = CODEGEN_DIR.Dir("boards")
GENERATOR = CODEGEN_DIR.File("generator.py")
TEMPLATES_DIR = CODEGEN_DIR.Dir("templates")

LIBRARIES_INC_DIR = LIB_DIR.Dir("ms-common").Dir("inc")

# Recursively get library dependencies for entry
def get_lib_deps(entry):
    config = parse_config(entry)
    deps = config['libs'] + config['{}_libs'.format(PLATFORM)]
    for dep in deps:
        deps += get_lib_deps(LIB_DIR.Dir(dep))
    return deps

def lib_bin(lib_name):
    return BIN_DIR.Dir(LIB_DIR.name).File('lib{}.a'.format(lib_name))

# ELFs are used for gdb and x86
def proj_elf(proj_name, is_smoke=False):
    return BIN_DIR.Dir(SMOKE_DIR.name if is_smoke else PROJ_DIR.name).File(proj_name)

# .bin is used for flashing to MCU
def proj_bin(proj_name, is_smoke=False):
    return proj_elf(proj_name, is_smoke).File(proj_name + '.bin')

###########################################################
# Header file generation from jinja templates
###########################################################
def generate_can_files(env, target=[], source=[], project=TARGET, is_smoke=False):
    source_yaml = BOARDS_DIR.File(project + ".yaml")
    if is_smoke:
        project_can_dir = OBJ_DIR.Dir("smoke").Dir(project).Dir("can")
    else:
        project_can_dir = OBJ_DIR.Dir("projects").Dir(project).Dir("can")
    source_dir = project_can_dir.Dir("src")
    header_dir = project_can_dir.Dir("inc")
    source += [BOARDS_DIR, TEMPLATES_DIR, GENERATOR]
    
    header_files = []
    source_files = []
    source_command = f"-f {source_dir} -t"
    header_command = f"-f {header_dir} -t"

    # TODO: Fix up system_can.dbc output directory
    for template in TEMPLATES_DIR.glob('*.jinja'):
        # name of output file
        file_name = os.path.splitext(template.name)[0]
        if file_name.startswith("_"):
            file_name = project + file_name
        if file_name == "can.py":
            env.Command(
                PY_DIR.File(file_name),
                [BOARDS_DIR, TEMPLATES_DIR, GENERATOR],
                f"python3 {GENERATOR} -f {PY_DIR} -t {template.name}"
            )
        elif file_name == "can_board_ids.h":
            env.Command(
                LIBRARIES_INC_DIR.File(file_name),
                [BOARDS_DIR, TEMPLATES_DIR, GENERATOR],
                f"python3 {GENERATOR} -f {LIBRARIES_INC_DIR} -t {template.name}"
            )
            target.append(LIBRARIES_INC_DIR.File(file_name))
        elif ".c" in file_name:
            source_command += " " + template.name
            source_files.append(source_dir.File(file_name))
        else:
            header_command += " " + template.name
            header_files.append(header_dir.File(file_name))

    source.append(source_yaml)
    # env.Command(header_files, source, f"python3 {GENERATOR} -b {project} {header_command}")
    # env.Command(source_files, source, f"python3 {GENERATOR} -b {project} {source_command}")
    command = f"python3 {GENERATOR} -b {project} {source_command} {header_command}"
    env.Command(header_files + source_files, source, command)

    # Add a VariantDir that point to can folder. Create the can target specific for the project
    VariantDir(project_can_dir, CAN_DIR, duplicate=0)
    source_files = []
    source_files += project_can_dir.Dir('src').glob('*.[cs]')
    source_files += project_can_dir.Dir('src').Dir(PLATFORM).glob('*.[cs]')

    target += source_files + header_files
    return source_files, header_dir

def addBuildPath(string: str):
    if (not string.startswith('build')):
        return f"#/{OBJ_DIR.path}/{string}"
    else:
        return f"#/{string}"

# Create appropriate targets for all projects and libraries
for entry in PROJ_DIRS + LIB_DIRS + SMOKE_DIRS:
    srcs = []
    inc_dirs = []
    lib_incs = []
    
    config = parse_config(entry)
    
    if config["can"]:
        is_smoke = entry in SMOKE_DIRS
        can_location_name = entry.name

        # Add Autogenerated files
        can_sources, can_header_dir = generate_can_files(env, project=can_location_name, is_smoke=is_smoke)
        srcs += can_sources
        inc_dirs.append(can_header_dir)
    
    if "include" in config:
        for i in config["include"]:
            inc_dirs.append(Dir(i))

    if "sources" in config:
        for i in config["sources"]:
            srcs.append(File(i))

    # Glob the source files from OBJ_DIR because it's a variant dir
    # See: https://scons.org/doc/1.2.0/HTML/scons-user/x3346.html
    # str(entry) is e.g. 'projects/example', so this is like build/obj/projects/example/src
    srcs += entry.Dir('src').glob('*.[cs]')
    srcs += entry.Dir('src').Dir(PLATFORM).glob('*.[cs]')
    
    inc_dirs.append(entry.Dir('inc'))
    inc_dirs.append(entry.Dir('inc').Dir(PLATFORM))

    # Just include all library headers
    # This resolves dependency issues like ms-freertos including FreeRTOS headers
    # even though FreeRTOS depends on ms-freertos, not the other way around
    lib_incs += [lib_dir.Dir('inc') for lib_dir in LIB_DIRS]
    lib_incs += [lib_dir.Dir('inc').Dir(PLATFORM) for lib_dir in LIB_DIRS]

    # Add #/build/{PLATFORM} to srcs path so that .o files stays in build
    srcs = [addBuildPath(x.path) for x in srcs]
    inc_dirs = [addBuildPath(x.path) for x in inc_dirs]

    env.Append(CPPDEFINES=[GetOption('define')])
    if entry in PROJ_DIRS or entry in SMOKE_DIRS:
        # print(entry, srcs)
        is_smoke = entry in SMOKE_DIRS
        lib_deps = get_lib_deps(entry)
        output = proj_elf(entry.name, is_smoke)
        # SCons automagically handles object creation and linking

        target = env.Program(
            target=output,
            source=srcs,
            CPPPATH=env['CPPPATH'] + [inc_dirs, lib_incs],
            # link each library twice so that dependency cycles are resolved
            # See: https://stackoverflow.com/questions/45135
            LIBS=env['LIBS'] + lib_deps * 2,
            LIBPATH=[LIB_BIN_DIR],
            CCFLAGS=env['CCFLAGS'] + config['cflags'],
        )
        
        # .bin file only required for arm, not x86
        if PLATFORM == 'arm':
            target = env.Bin(target=proj_bin(entry.name, is_smoke), source=target)  
    elif entry in LIB_DIRS:
        output = lib_bin(entry.name)
        target = env.Library(
            target=output,
            source=srcs,
            CPPPATH=env['CPPPATH'] + [inc_dirs, lib_incs],
            CCFLAGS=env['CCFLAGS'] + config['cflags'],
        )
                
    # Create an alias for the entry so we can do `scons leds` and it Just Works
    Alias(entry.name, target)

###########################################################
# Python
###########################################################

# Build all projects when you just run `scons`
if (TYPE != 'python'):
    Default(TARGET or [proj.name for proj in PROJ_DIRS])
else:
    py = Command('py.txt', [], f"PYTHONPATH=py python3 py/{TARGET}/main.py")
    Default(py)
    Depends(py, PY_DIR.File("can.py"))
