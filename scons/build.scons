from scons.common import parse_config
from pathlib import Path

Import("VARS")

TARGET = VARS.get("TARGET")
PLATFORM = VARS.get("PLATFORM")
env = VARS.get("env")

ROOT = Dir('#')

BUILD_DIR = ROOT.Dir('build').Dir(PLATFORM)
BIN_DIR = BUILD_DIR.Dir('bin')
OBJ_DIR = BUILD_DIR.Dir('obj')
TEST_DIR = BUILD_DIR.Dir('test')

PY_DIR = ROOT.Dir('py')
PROJ_DIR = ROOT.Dir('projects')
LIB_DIR = ROOT.Dir('libraries')
SMOKE_DIR = ROOT.Dir('smoke')

LIB_BIN_DIR = BIN_DIR.Dir('libraries')

CODEGEN_DIR = LIB_DIR.Dir("codegen")
BOARDS_DIR = CODEGEN_DIR.Dir("boards")
GENERATOR = CODEGEN_DIR.File("generator.py")
TEMPLATES_DIR = CODEGEN_DIR.Dir("templates")

LIBRARIES_INC_DIR = LIB_DIR.Dir("ms-common").Dir("inc")


def src(path):
    # return all source files within a path
    srcs = []
    for file in path.glob("src/*.[cs]") + path.glob(f"src/{PLATFORM}/*.[cs]"):
        if file.abspath.startswith(OBJ_DIR.abspath):
            srcs.append(file)
        else:
            srcs.append(OBJ_DIR.File(file.path))
    return srcs


def inc(path):
    # return all include directories within a path
    return [path.Dir("inc"), path.Dir("inc").Dir(PLATFORM)]


def get_lib_deps(entry):
    # Recursively get library dependencies for entry
    config = parse_config(entry)
    deps = config['libs'] + config['{}_libs'.format(PLATFORM)]
    for dep in deps:
        deps += get_lib_deps(LIB_DIR.Dir(dep))
    return deps


###########################################################
# Header file generation from jinja templates
###########################################################
autogen_sources = [BOARDS_DIR.glob("*"), TEMPLATES_DIR.glob("*"), GENERATOR]

env.Command(
    LIBRARIES_INC_DIR.File("can_board_ids.h"),
    autogen_sources,
    env.Action(f"python3 {GENERATOR} -f {LIBRARIES_INC_DIR} -t can_board_ids.h.jinja",
               f"Autogen    {LIBRARIES_INC_DIR}/can_board_ids.h")
)


def generate_can_files(env, project):
    project_can_dir = OBJ_DIR.Dir(project).Dir("can")
    source_dir = project_can_dir.Dir("src")
    header_dir = project_can_dir.Dir("inc")
    header_files = []
    source_files = []
    source_command = f"-f {source_dir} -t"
    header_command = f"-f {header_dir} -t"

    # TODO: Fix up system_can.dbc output directory
    # project specific files
    header_command += " can_codegen.h.jinja"
    header_files.append(header_dir.File("can_codegen.h"))
    for template in TEMPLATES_DIR.glob('_*.jinja'):
        # name of output file
        file_name = Path(project).stem + Path(template.name).stem
        if ".c" in file_name:
            source_command += " " + template.name
            source_files.append(source_dir.File(file_name))
        else:
            header_command += " " + template.name
            header_files.append(header_dir.File(file_name))

    command = env.Action(f"python3 {GENERATOR} -b {Path(project).stem} {source_command} {header_command}",
                         f"Autogen    {project} can files")
    # print([f.path for f in header_files + source_files])
    env.Command(header_files + source_files, autogen_sources, command)

    # Add a VariantDir that point to can folder. Create the can target specific for the project
    VariantDir(project_can_dir, ROOT.Dir('can'), duplicate=0)
    return src(project_can_dir), [header_dir] + inc(ROOT.Dir("can"))


###########################################################
# Create appropriate targets for all libraries
###########################################################
# Just include all library headers
# This resolves dependency issues like ms-freertos including FreeRTOS headers
# even though FreeRTOS depends on ms-freertos, not the other way around
lib_incs = [inc(lib_dir) for lib_dir in LIB_DIR.glob('*')]
for entry in LIB_DIR.glob('*'):
    config = parse_config(entry)
    lib_deps = get_lib_deps(entry)
    target = env.Library(
        target=LIB_BIN_DIR.File(f'lib{entry.name}.a'),
        source=src(entry),
        LIBS=env['LIBS'] + lib_deps * 2,
        LIBPATH=[LIB_BIN_DIR],
        CPPPATH=env['CPPPATH'] + lib_incs,
        CCFLAGS=env['CCFLAGS'] + config['cflags'],
    )
    Alias(entry.path, target)
    Alias(entry.name, target)

###########################################################
# Create appropriate targets for all projects and smoke projects
###########################################################
for entry in PROJ_DIR.glob('*') + SMOKE_DIR.glob('*'):
    config = parse_config(entry)

    incs = inc(entry)
    srcs = src(entry)

    if config["can"]:
        # Add Autogenerated files
        can_sources, can_headers = generate_can_files(env, entry.path)
        srcs += can_sources
        incs += can_headers

    incs += map(ROOT.Dir, config.get("include", []))
    srcs += map(OBJ_DIR.File, config.get("sources", []))

    lib_deps = get_lib_deps(entry)
    # SCons automagically handles object creation and linking
    target = env.Program(
        target=BIN_DIR.File(entry.path),
        source=srcs,
        CPPPATH=env['CPPPATH'] + incs + lib_incs,
        # link each library twice so that dependency cycles are resolved
        # See: https://stackoverflow.com/questions/45135
        LIBS=env['LIBS'] + lib_deps * 2,
        LIBPATH=[LIB_BIN_DIR],
        CCFLAGS=env['CCFLAGS'] + config['cflags'],
    )

    # .bin file only required for arm, not x86
    if PLATFORM == 'arm':
        target = env.Bin(target=BIN_DIR.File(entry.path + '.bin'),
                         source=target)

    # Create an alias for the entry so we can do `scons leds` and it Just Works
    Alias(entry.path, target)
    Alias(entry.name, target)

###########################################################
# Python
###########################################################
for entry in PY_DIR.glob("*", exclude=["*.*", "__pycache__"]):
    target = env.Command(entry.path, [],
                         f"PYTHONPATH={PY_DIR.path} python3 {entry.path}/main.py")
    Alias(entry.path, target)
    Alias(entry.name, target)

# Build all projects when you just run `scons`
Default(TARGET or [e.path for e in PROJ_DIR.glob('*')])
