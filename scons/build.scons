from scons.common import parse_config
from pathlib import Path

Import("VARS")

TARGET = VARS.get("TARGET")
PLATFORM = VARS.get("PLATFORM")
env = VARS.get("env")

ROOT = Dir('#')

BUILD_DIR = ROOT.Dir('build').Dir(PLATFORM)
BIN_DIR = BUILD_DIR.Dir('bin')
OBJ_DIR = BUILD_DIR.Dir('obj')
TEST_DIR = BUILD_DIR.Dir('test')

PY_DIR = ROOT.Dir('py')
PROJ_DIR = ROOT.Dir('projects')
LIB_DIR = ROOT.Dir('libraries')
SMOKE_DIR = ROOT.Dir('smoke')

LIB_BIN_DIR = BIN_DIR.Dir('libraries')

CODEGEN_DIR = ROOT.Dir("autogen")

LIBRARIES_INC_DIR = LIB_DIR.Dir("ms-common").Dir("inc")


def src(path):
    # return all source files within a path
    srcs = []
    for file in path.glob("src/*.[cs]") + path.glob(f"src/{PLATFORM}/*.[cs]"):
        if file.abspath.startswith(OBJ_DIR.abspath):
            srcs.append(file)
        else:
            srcs.append(OBJ_DIR.File(file.path))
    return srcs


def inc(path):
    # return all include directories within a path
    return [path.Dir("inc"), path.Dir("inc").Dir(PLATFORM)]


def get_lib_deps(entry):
    # Recursively get library dependencies for entry
    config = parse_config(entry)
    deps = config['libs'] + config['{}_libs'.format(PLATFORM)]
    for dep in deps:
        deps += get_lib_deps(LIB_DIR.Dir(dep))
    return deps


###########################################################
# Header file generation from jinja templates
###########################################################
autogen_sources = list(CODEGEN_DIR.glob("*"))
env.Command(
    PY_DIR.File("can.py"),
    autogen_sources,
    f"python3 -m autogen python_can -o py/can"
)
env.Command(
    LIBRARIES_INC_DIR.File("can_board_ids.h"),
    autogen_sources,
    f"python3 -m autogen can_board_ids -o libraries/ms-common/inc"
)


def generate_can_files(env, project):
    project_can_dir = OBJ_DIR.Dir(project).Dir("can")

    output_files = []

    project_name = Path(project).stem
    can_template_dir = Path(str(CODEGEN_DIR), "templates/can")
    for template in can_template_dir.glob('*/*.jinja'):
        template_path = template.relative_to(can_template_dir)
        output_name = str(template_path) \
            .replace(r"{{board}}", project_name) \
            .replace(".jinja", "")

        output_files.append(project_can_dir.File(output_name))

    # print([f.path for f in output_files])
    env.Command(output_files, autogen_sources,
                f"python3 -m autogen can -o {project_can_dir.path}")

    # Add a VariantDir that point to can folder. Create the can target specific for the project
    VariantDir(project_can_dir, ROOT.Dir('can'), duplicate=0)
    return src(project_can_dir), [project_can_dir.Dir("inc")] + inc(ROOT.Dir("can"))


###########################################################
# Create appropriate targets for all libraries
###########################################################
# Just include all library headers
# This resolves dependency issues like ms-freertos including FreeRTOS headers
# even though FreeRTOS depends on ms-freertos, not the other way around
lib_incs = [inc(lib_dir) for lib_dir in LIB_DIR.glob('*')]
for entry in LIB_DIR.glob('*'):
    config = parse_config(entry)
    lib_deps = get_lib_deps(entry)
    target = env.Library(
        target=LIB_BIN_DIR.File(f'lib{entry.name}.a'),
        source=src(entry),
        LIBS=env['LIBS'] + lib_deps * 2,
        LIBPATH=[LIB_BIN_DIR],
        CPPPATH=env['CPPPATH'] + lib_incs,
        CCFLAGS=env['CCFLAGS'] + config['cflags'],
    )
    Alias(entry.path, target)
    Alias(entry.name, target)

###########################################################
# Create appropriate targets for all projects and smoke projects
###########################################################
for entry in PROJ_DIR.glob('*') + SMOKE_DIR.glob('*'):
    config = parse_config(entry)

    incs = inc(entry)
    srcs = src(entry)

    if config["can"]:
        # Add Autogenerated files
        can_sources, can_headers = generate_can_files(env, entry.path)
        srcs += can_sources
        incs += can_headers

    incs += map(ROOT.Dir, config.get("include", []))
    srcs += map(OBJ_DIR.File, config.get("sources", []))

    lib_deps = get_lib_deps(entry)
    # SCons automagically handles object creation and linking
    target = env.Program(
        target=BIN_DIR.File(entry.path),
        source=srcs,
        CPPPATH=env['CPPPATH'] + incs + lib_incs,
        # link each library twice so that dependency cycles are resolved
        # See: https://stackoverflow.com/questions/45135
        LIBS=env['LIBS'] + lib_deps * 2,
        LIBPATH=[LIB_BIN_DIR],
        CCFLAGS=env['CCFLAGS'] + config['cflags'],
    )

    # .bin file only required for arm, not x86
    if PLATFORM == 'arm':
        target = env.Bin(target=BIN_DIR.File(entry.path + '.bin'),
                         source=target)

    # Create an alias for the entry so we can do `scons leds` and it Just Works
    Alias(entry.path, target)
    Alias(entry.name, target)

###########################################################
# Python
###########################################################
for entry in PY_DIR.glob("*", exclude=["*.*", "__pycache__"]):
    target = env.Command(entry.path, [],
                         f"PYTHONPATH={PY_DIR.path} python3 {entry.path}/main.py")
    Alias(entry.path, target)
    Alias(entry.name, target)

# Build all projects when you just run `scons`
Default(TARGET or [e.path for e in PROJ_DIR.glob('*')])
